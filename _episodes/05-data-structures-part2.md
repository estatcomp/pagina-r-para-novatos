---
title: "Explorando Data Frames"
Ensino: 20
Exercícios: 10
Questes:
- "Como manipular um data frame?"
Objetivo:
- Ser capaz de adicionar um remover linhas e colunas.
- Ser capaz de remover linhas com valores `NA`.
- Ser capaz de juntar dois data frames.
- Ser capaz de articular o que um `factor` é e como converter entre `fator`e `character`
- Ser capaz de procurar propriedades básicas de um data frame incluindo tamanho, classe ou tipo das colunas, nomes, e as primeiras linhas.
Pontos chave:
- Usar `cbind()` para adicionar uma nova coluna a um data frame.
- Usar `rbind()` para adicionar uma nova linha a um data frame.
- Remover linhas de um data frame.
- Usar `na.omit()` para remover linhas de um data frame com valor `NA`.
- Usar `levels()` e `as.character()` para explorar e manipular fatores.
- Usar `str()`, `nrow()`, `ncol()`, `dim()`, `colnames()`, `rownames()`, `head()` and
  `typeof()` para entender a estrutura do data frame.
- Ler um arquivo csv usando `read.csv()`
- Entender `length()` de um data frame
source: Rmd
---



Neste ponto, você viu isso tudo - na última lição, nós visitamos todos os tipos básicos
de dados e estruturas de dados no R. Tudo o que você fará será uma manipulação destas
ferramentas. Mas na maior parte do tempo, a estrela do show será o
data frame - a tabela que nós criamos carregando informação de um arquivo csv. Nesta lição, 
nós iremos aprender algumas coisas a mais sobre trabalhar com data frames.

## Adicionando colunas e linhas a um data frame

Aprendemos anteriormente que colunas em um data frame eram vetores, tal que nossos
dados eram consistentes em tipo por coluna. Tal que, se nós quiséssemos adicionar uma
nova coluna nós precisaríamos começar fazendo um novo vetor:





~~~
age <- c(2,3,5,12)
cats
~~~
{: .r}



~~~
    coat weight likes_string
1 calico    2.1            1
2  black    5.0            0
3  tabby    3.2            1
~~~
{: .output}

Nós podemos então adicionar como uma nova coluna via:


~~~
cats <- cbind(cats, age)
~~~
{: .r}



~~~
Error in data.frame(..., check.names = FALSE): arguments imply differing number of rows: 3, 4
~~~
{: .error}

Por que isso não funcionou? Com certeza, o R quer ver um elemento em nossa nova coluna
para cada linha da tabela:


~~~
cats
~~~
{: .r}



~~~
    coat weight likes_string
1 calico    2.1            1
2  black    5.0            0
3  tabby    3.2            1
~~~
{: .output}



~~~
age <- c(4,5,8)
cats <- cbind(cats, age)
cats
~~~
{: .r}



~~~
    coat weight likes_string age
1 calico    2.1            1   4
2  black    5.0            0   5
3  tabby    3.2            1   8
~~~
{: .output}
Agora como adicionar linhas - neste caso, nós vimos da última vez que a linhas
de um data frame são feitas de listas:


~~~
newRow <- list("tortoiseshell", 3.3, TRUE, 9)
cats <- rbind(cats, newRow)
~~~
{: .r}



~~~
Warning in `[<-.factor`(`*tmp*`, ri, value = "tortoiseshell"): invalid
factor level, NA generated
~~~
{: .error}

## Fatores

Outra coisa para se prestar atenção surgiu - quando o R cria um fator, ele apenas
permite os que estavam originalmente na tabela quando os dados foram carregados pela
primeira vez, os quais eram 'black', 'calico' e 'tabby' em nosso caso. Qualquer coisa
nova que não se ajustar em uma das categorias é rejeitada como sem sentido (transforma-se NA).

O aviso está dizendo que não conseguimos adicionar 'tortoiseshell' ao nosso
fator *coat*, mas 3.3 (um número), TRUE (um lógico) e 9 (um número) foram 
adicionados com sucesso a *weight*, *likes_string*, e *age*, respectivamente, desde
que esses valores não são fatores e um gato com um 
*coat* 'tortoiseshell', explicitamente adicionar 'tortoiseshell' como um *nível* no fator:


~~~
levels(cats$coat)
~~~
{: .r}



~~~
[1] "black"  "calico" "tabby" 
~~~
{: .output}



~~~
levels(cats$coat) <- c(levels(cats$coat), 'tortoiseshell')
cats <- rbind(cats, list("tortoiseshell", 3.3, TRUE, 9))
~~~
{: .r}
Alternativamente, nós podemos modificar uma coluna de fatores para um vetor de caracteres; nós perdemos
o acesso a categorias do fator, mas podemos subsequentemente adicionar qualquer palavra à 
coluna sem necessidade de vigiar os níveis do fator:


~~~
str(cats)
~~~
{: .r}



~~~
'data.frame':	5 obs. of  4 variables:
 $ coat        : Factor w/ 4 levels "black","calico",..: 2 1 3 NA 4
 $ weight      : num  2.1 5 3.2 3.3 3.3
 $ likes_string: int  1 0 1 1 1
 $ age         : num  4 5 8 9 9
~~~
{: .output}



~~~
cats$coat <- as.character(cats$coat)
str(cats)
~~~
{: .r}



~~~
'data.frame':	5 obs. of  4 variables:
 $ coat        : chr  "calico" "black" "tabby" NA ...
 $ weight      : num  2.1 5 3.2 3.3 3.3
 $ likes_string: int  1 0 1 1 1
 $ age         : num  4 5 8 9 9
~~~
{: .output}
## Removendo Linhas

Nós sabemos como adicionar linhas e colunas ao nosso data frame no R - mas em nossa
primeira tentativa de adicionar um gato 'casco de tartaruga' ao data frame, nós acidentalmente
adicionamos uma linha errada:


~~~
cats
~~~
{: .r}



~~~
           coat weight likes_string age
1        calico    2.1            1   4
2         black    5.0            0   5
3         tabby    3.2            1   8
4          <NA>    3.3            1   9
5 tortoiseshell    3.3            1   9
~~~
{: .output}

We can ask for a data frame minus this offending row:


~~~
cats[-4,]
~~~
{: .r}



~~~
           coat weight likes_string age
1        calico    2.1            1   4
2         black    5.0            0   5
3         tabby    3.2            1   8
5 tortoiseshell    3.3            1   9
~~~
{: .output}
Note que a vírgula com nada após indica que queremos remover a quarta linha inteiramente.

Nota: Nós podemos também remover várias linhas de uma só vez colocando as linhas
em um vetor: `cats[c(-4,-5),]`

Alternativaente, nós podemos tirar todas as linhas com valores `NA`:


~~~
na.omit(cats)
~~~
{: .r}



~~~
           coat weight likes_string age
1        calico    2.1            1   4
2         black    5.0            0   5
3         tabby    3.2            1   8
5 tortoiseshell    3.3            1   9
~~~
{: .output}

Vamos reatribuir a saída de `cats`, tal que nossas mudanças sejam permanentes:


~~~
cats <- na.omit(cats)
~~~
{: .r}

## Anexando a um data frame

A chave para lembrar quando adicionar dados a um data frame é *colunas são
vetores ou fatores, e linhas são listas.* Podemos também juntar dois data frames
com `rbind`:


~~~
cats <- rbind(cats, cats)
cats
~~~
{: .r}



~~~
            coat weight likes_string age
1         calico    2.1            1   4
2          black    5.0            0   5
3          tabby    3.2            1   8
5  tortoiseshell    3.3            1   9
11        calico    2.1            1   4
21         black    5.0            0   5
31         tabby    3.2            1   8
51 tortoiseshell    3.3            1   9
~~~
{: .output}

Mas agora o nome das linhas estão desnecessariamente complicados. Nós podemos
remover o nome das linhas, e R irá renomeá-las sequencialmente:


~~~
rownames(cats) <- NULL
cats
~~~
{: .r}



~~~
           coat weight likes_string age
1        calico    2.1            1   4
2         black    5.0            0   5
3         tabby    3.2            1   8
4 tortoiseshell    3.3            1   9
5        calico    2.1            1   4
6         black    5.0            0   5
7         tabby    3.2            1   8
8 tortoiseshell    3.3            1   9
~~~
{: .output}

> ## Desafio 1
>
> Você pode criar um novo data frame direto de dentro do R com a seguinte sintáxe:
> 
> ~~~
> df <- data.frame(id = c('a', 'b', 'c'),
>                  x = 1:3,
>                  y = c(TRUE, TRUE, FALSE),
>                  stringsAsFactors = FALSE)
> ~~~
> {: .r}
> Fazer um data frame que contém as seguintes informação sobre você mesmo:
>
> - Nome (name)
> - Sobrenome (last name)
> - Número da sorte (lucky number)
>
> Então use `rbind` para adicionar um novo registro da pessoa sentada ao teu lado.
> Finalmente, utilize `cbind` para adicionar uma coluna para cada pessoa a responder a questão, "É hora do coffee break?"
>
> > ## Solution to Challenge 1
> > 
> > ~~~
> > df <- data.frame(first = c('Grace'),
> >                  last = c('Hopper'),
> >                  lucky_number = c(0),
> >                  stringsAsFactors = FALSE)
> > df <- rbind(df, list('Marie', 'Curie', 238) )
> > df <- cbind(df, coffeetime = c(TRUE,TRUE))
> > ~~~
> > {: .r}
> {: .solution}
{: .challenge}

## Exemplo realista
Até agora, você viu o básico de manipulação de data frames com nossos dados sobre gatos;
agora vamos utilizar essas habilidades para resumir um conjunto de dados mais realista.
Vamos ler os dados do conjunto gapminder que baixamos previamente:


~~~
gapminder <- read.csv("data/gapminder-FiveYearData.csv")
~~~
{: .r}

> ## Dicas Variadas
>
> * Outro tipo de arquivo que você deve encontrar são os dados separados por tabulação, do inglês tab-separetad value files (.tsv). Para especificar tabulação como um separador, utilize `"\\t"` ou `read.delim()`.
>
> * Arquivo também podem ser baixados diretamente da internet para uma pasta local
> de seu escolha dentro de seu computador utilizando a função `dowbload.file`.
> A função `read.csv` pode ser executada para ler o arquivo baixado, por exemplo:
> 
> ~~~
> download.file("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder-FiveYearData.csv", destfile = "data/gapminder-FiveYearData.csv")
> gapminder <- read.csv("data/gapminder-FiveYearData.csv")
> ~~~
> {: .r}
>
> * Alternativamente, você pode também ler arquivos da internet diretamente no R trocando o endereço da pasta por um endereço da web em `read.csv`. Deve-se notar que ao fazer isso nenhuma cópia do arquivo será salva no computador. Por exemplo,
> 
> ~~~
> gapminder <- read.csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder-FiveYearData.csv")
> ~~~
> {: .r}
>
> * Podemos ler diretamente uma tabela excel sem
> converter em texto usando o pacote [readxl](https://cran.r-project.org/web/packages/readxl/index.html)
{: .callout}

Vamos investigar um pouco o gapminder; a primeira coisa que sempre devemos
fazer é checar como os dados estão organizados com `str`:


~~~
str(gapminder)
~~~
{: .r}



~~~
'data.frame':	1704 obs. of  6 variables:
 $ country  : Factor w/ 142 levels "Afghanistan",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...
 $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...
 $ continent: Factor w/ 5 levels "Africa","Americas",..: 3 3 3 3 3 3 3 3 3 3 ...
 $ lifeExp  : num  28.8 30.3 32 34 36.1 ...
 $ gdpPercap: num  779 821 853 836 740 ...
~~~
{: .output}

We can also examine individual columns of the data frame with our `typeof` function:


~~~
typeof(gapminder$year)
~~~
{: .r}



~~~
[1] "integer"
~~~
{: .output}



~~~
typeof(gapminder$country)
~~~
{: .r}



~~~
[1] "integer"
~~~
{: .output}



~~~
str(gapminder$country)
~~~
{: .r}



~~~
 Factor w/ 142 levels "Afghanistan",..: 1 1 1 1 1 1 1 1 1 1 ...
~~~
{: .output}

We can also interrogate the data frame for information about its dimensions;
remembering that `str(gapminder)` said there were 1704 observations of 6
variables in gapminder, what do you think the following will produce, and why?


~~~
length(gapminder)
~~~
{: .r}



~~~
[1] 6
~~~
{: .output}

A fair guess would have been to say that the length of a data frame would be the
number of rows it has (1704), but this is not the case; remember, a data frame
is a *list of vectors and factors*:


~~~
typeof(gapminder)
~~~
{: .r}



~~~
[1] "list"
~~~
{: .output}

When `length` gave us 6, it's because gapminder is built out of a list of 6
columns. To get the number of rows and columns in our dataset, try:


~~~
nrow(gapminder)
~~~
{: .r}



~~~
[1] 1704
~~~
{: .output}



~~~
ncol(gapminder)
~~~
{: .r}



~~~
[1] 6
~~~
{: .output}

Or, both at once:


~~~
dim(gapminder)
~~~
{: .r}



~~~
[1] 1704    6
~~~
{: .output}

We'll also likely want to know what the titles of all the columns are, so we can
ask for them later:


~~~
colnames(gapminder)
~~~
{: .r}



~~~
[1] "country"   "year"      "pop"       "continent" "lifeExp"   "gdpPercap"
~~~
{: .output}

At this stage, it's important to ask ourselves if the structure R is reporting
matches our intuition or expectations; do the basic data types reported for each
column make sense? If not, we need to sort any problems out now before they turn
into bad surprises down the road, using what we've learned about how R
interprets data, and the importance of *strict consistency* in how we record our
data.

Once we're happy that the data types and structures seem reasonable, it's time
to start digging into our data proper. Check out the first few lines:


~~~
head(gapminder)
~~~
{: .r}



~~~
      country year      pop continent lifeExp gdpPercap
1 Afghanistan 1952  8425333      Asia  28.801  779.4453
2 Afghanistan 1957  9240934      Asia  30.332  820.8530
3 Afghanistan 1962 10267083      Asia  31.997  853.1007
4 Afghanistan 1967 11537966      Asia  34.020  836.1971
5 Afghanistan 1972 13079460      Asia  36.088  739.9811
6 Afghanistan 1977 14880372      Asia  38.438  786.1134
~~~
{: .output}

To make sure our analysis is reproducible, we should put the code
into a script file so we can come back to it later.

> ## Challenge 2
>
> Go to file -> new file -> R script, and write an R script
> to load in the gapminder dataset. Put it in the `scripts/`
> directory and add it to version control.
>
> Run the script using the `source` function, using the file path
> as its argument (or by pressing the "source" button in RStudio).
>
> > ## Solution to Challenge 2
> > The contents of `script/load-gapminder.R`:
> > 
> > ~~~
> > download.file("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/gh-pages/_episodes_rmd/data/gapminder-FiveYearData.csv", destfile = "data/gapminder-FiveYearData.csv")
> > gapminder <- read.csv(file = "data/gapminder-FiveYearData.csv")
> > ~~~
> > {: .r}
> > To run the script and load the data into the `gapminder` variable:
> > 
> > ~~~
> > source(file = "scripts/load-gapminder.R")
> > ~~~
> > {: .r}
> {: .solution}
{: .challenge}

> ## Challenge 3
>
> Read the output of `str(gapminder)` again;
> this time, use what you've learned about factors, lists and vectors,
> as well as the output of functions like `colnames` and `dim`
> to explain what everything that `str` prints out for gapminder means.
> If there are any parts you can't interpret, discuss with your neighbors!
>
> > ## Solution to Challenge 3
> >
> > The object `gapminder` is a data frame with columns
> > - `country` and `continent` are factors.
> > - `year` is an integer vector.
> > - `pop`, `lifeExp`, and `gdpPercap` are numeric vectors.
> >
> {: .solution}
{: .challenge}
