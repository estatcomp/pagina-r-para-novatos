---
title: "Estruturas de dados"
teaching: 40
exercises: 15
questions:
- "Como eu posso ler dados no R?"
- "Quais s√£o os tipos b√°sicos de dados no R?"
- "Como eu represento informa√ß√µes categ√≥ricas em R?"
objectives:
- "Conhecer os diferentes tipos de dados."
- "Come√ßar a explorar data frames, e entender como eles est√£o relacionados a vetores, fatores e listas."
- "Ser capaz de perguntar ao R quest√µes sobre o tipo, classe e estrutura de um objeto."
keypoints:
- "Usar `read.csv` para ler dados tabulares em R."
- "Os tipos b√°sicos de dados em R s√£o double, inteiro, complexo, l√≥gico e caractere."
- "Usar fatores para representar categorias em R."
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")

## Salvando os dados
cats_orig <- data.frame(coat = factor(c("calico", "black", "tabby")),
                   weight = c(2.1, 5.0, 3.2),
                   likes_string = c(1, 0, 1))
cats_bad <- data.frame(coat = factor(c("calico", "black", "tabby", "tabby")),
                   weight = factor(c(2.1, 5.0, 3.2, '2.3 or 2.4')),
                   likes_string = c(1, 0, 1, 1))
cats <- cats_orig
```

Uma das caracter√?sticas mais poderosas do R √© sua capacidade de lidar com dados em tabelas - como voc√™ j√° deve ter visto em uma planilha em CSV. Vamos come√ßar fazendo um banco de dados para testes na sua pasta `data/`, chamado _ directory, called `feline-data.csv`:

```{r, eval=FALSE}
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
```

> ## Dica: Editando arquivos de texto em R
>
> Alternativamente, voc√™ pode criar `data/feline-data.csv` usando um editor de texto
> (Nano), ou dentro do RStudio com o item do menu **Arquivo -> Novo Arquivo -> Arquivo de texto**.
{: .callout}

```{r, echo = FALSE}
cats.df <- data.frame(coat = c("calico", "black", "tabby"),
                      weight = c(2.1, 5.0, 3.2),
                      likes_string = c(1, 0, 1))
write.csv(cats.df, "data/feline-data.csv", row.names = FALSE)
```

Voc√™ pode carregar isso no R com o seguinte comando:

```{r}
cats <- read.csv(file = "data/feline-data.csv")
cats
```

A fun√ß√£o `read.csv` √© utilizada para ler dados de tabelas armazenados em um arquivo de texto onde as colunas s√£o delimitadas por v√?rgulas (csv = comma separated values, i.e., valores separados por v√?rgulas). Tabs tamb√©m s√£o comumente usados para separar colunas - se os seus dados est√£o neste formato voc√™ pode usar a fun√ß√£o `read.delim`. Se as colunas nos seus dados s√£o delimitadas por um outro caractere al√©m de v√?rgulas ou tabs, voc√™ pode usar a fun√ß√£o `read.table`, que √© mais geral e flex√?vel.


J√° podemos come√ßar a explorar o nosso banco de dados, imprimindo colunas especificando elas com o operador `$`:

```{r}
cats$weight
cats$coat
```

N√≥s podemos fazer outras opera√ß√µes nas colunas:

```{r}
## Digamos que n√≥s descobrimos que a escala de quilos tem dois Kg a menos:
cats$weight + 2
paste("My cat is", cats$coat)
```

Mas e se fizermos

```{r}
cats$weight + cats$coat
```

Entendendo o que aconteceu aqui √© a chave para analisar dados em R de maneira satisfat√≥ria.

## Tipos de Dados

Se voc√™ imaginasse que o √∫ltimo comando fosse retornar um erro porque `2.1` mais `"black"` n√£o faz sentido, voc√™ estava certo - e voc√™ j√° tem alguma intui√ß√£o para um importante conceito em programa√ß√£o chamado *tipos de dados*. Podemos perguntar que tipo de dado algo √©:

```{r}
typeof(cats$weight)
```

Existem 5 tipos principais de dados:`duplo`, `inteiro`, `complexo`, `l√≥gico` e `caracter`.

```{r}
typeof(3.14)
typeof(1L) # O sufixo L for√ßa o n√∫mero a ser um inteiro, uma vez que o padr√£o do R usa n√∫meros fltuantes
typeof(1+1i)
typeof(TRUE)
typeof('banana')
```

N√£o importa qu√£o complicada sua analize se torne, todos os dados em R s√£o interpretados como um desses tipos b√°sicos de dados.Esse rigor tem algumas consequ√™ncias importantes. 
Um usu√°rio adicionou detalhes sobre outro gato. Essas informa√ß√µes est√£o no aquivo
`data/feline-data_v2.csv`.


```{r, eval=FALSE}
file.show("data/feline-data_v2.csv")
```

```{r, eval=FALSE}
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
tabby,2.3 or 2.4,1
```

Carregue os novos dados sobre os gatos como anteriormente, e cheque que tipos de dados acharemos na
coluna`weight`: 

```{r}
cats <- read.csv(file="data/feline-data_v2.csv")
typeof(cats$weight)
```


Ah n√£o, nossos pesos n√£o est√£o mais no tipo double! Se tentarmos usar a mesma l√≥gica que usamos antes, teremos problemas: 

```{r}
cats$weight + 2
```

O que aconteceu? Quando o R l√™ um csv nessas tabelas, ele insiste que tudo na coluna seja do mesmo tipo b√°sico; se ele n√£o pode entender *tudo* na coluna como double, ent√£o *ningu√©m* na coluna ser√° double. A tabela em que o R carregou os dados dos gatos √© algo chamado *data.frame*, e esse √© o nosso primeiro exemplo de algo chamado *estrutura de dados* - que √©, a estrutura em que o R sabe construir os tipos de dados b√°sicos. 

Conseguimos ver que isso √© um *data.frame* adicionando a fun√ß√£o `class` nele:

```{r}
class(cats)
```

Para utlizarmos com sucesso nossos dados no R, precisamos entender o que as estrutaras b√°sicas de dados s√£o, e como elas se comportam.Por hora, vamos remover aquela linha extra dos nossos dados e recarreg√°-lo, enquanto aprofundamos a investiga√ß√£o desse comportamento:

feline-data.csv:

```
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
```

E de volta ao RStudio:

```{r, eval=FALSE}
cats <- read.csv(file="data/feline-data.csv")
```

```{r, include=FALSE}
cats <- cats_orig
```


## Vetores e Coer√ß√£o de Tipo

Para melhor entender esse comportamento, vamos conhecer mais outra estrutura de dados:
O *vetor*.

```{r}
my_vector <- vector(length = 3)
my_vector
```

Um vetor em R √© essencialmente uma lista de coisas, com a condi√ß√£o especial que *tudo  no vetor precisa ser do mesmo tipo b√°sico de dados*. Se voc√™ n√£o escolher o tipo de dados, ele ser√° padronizado como `logico`; ou, voc√™ pode declarar um vetor vazio do tipo que voc√™ quiser.


```{r}
another_vector <- vector(mode='character', length=3)
another_vector
```

Voc√™ pode checar se algo √© um vetor:

```{r}
str(another_vector)
```

Essa sa√?da um tanto enigm√°tica para esse comando indica o tipo b√°sico de dados encontrados no vetor - nesse caso `chr`, caracter; uma indica√ß√£o do n√∫mero de coisas no vetor - na realidade, os √?ndices do vetor, nesse caso `[1:3]`; e alguns exemplos do que est√° no vetor - nesse caso uma s√©rie vazia de caracteres. Se similarmente fizermos

```{r}
str(cats$weight)
```

Veremos que isto √© um vetor, tamb√©m - *as colunas de dados que carregamos nos data.frames do R s√£o todos vetores*, e essa √© a raiz do porque que o R for√ßa tudo em uma coluna a ser do mesmo tipo b√°sico de dados. 

> ## Discuss√£o 1
>
> Porque o R √© t√£o rigoroso sobre o que colocamos em nossas colunas de dados?
> Como isso nos ajuda?
>
> > ## Discuss√£o 1
> >
> > Mantendo tudo na culuna o mesmo, nos possibilitamos fazer simples suposi√ß√µes > >a respeito de nossos dados; se voc√™ pode interpretar uma entrada na coluna 
> >como um n√∫mero, ent√£o pode interpretar *todos* eles como n√∫meros, e ent√£o n√£o
> >precisaremos checar toda vez. Essa consist√™ncia, como usar consistentemente o > >mesmo separador nos nossos aquivos de dados, √© o que as pessoas querem dizer 
> >quando falam em *dados limpos*; no longo prazo essa consistencia contribui 
> >para tornar nossa vida mais f√°cil no R. 
> {: .solution}
{: .discussion}

Voc√™ tamb√©m pode criar vetores com conteudos expl√?citos com a fun√ß√£o combine:

```{r}
combine_vector <- c(2,6,3)
combine_vector
```

Dado o que aprendemos at√© agora, o que voc√™ acha que ir√° produzir o seguinte?

```{r}
quiz_vector <- c(2,6,'3')
```

Isso √© algo chamado *coer√ß√£o de tipo*, e √© a fonte de muitas surpesas e a raz√£o de precisarmos estar alertas ao tipo b√°sico de dados e como o R ir√° interpret√°-los.Quando o R encontra uma mistura de tipos (aqui, num√©rico e caracter) para combinar em um √∫nico vetor, ele ir√° for√ß√°-los todos para serem do mesmo tipo. Considere:

```{r}
coercion_vector <- c('a', TRUE)
coercion_vector
another_coercion_vector <- c(0, TRUE)
another_coercion_vector
```

A regra de coer√ß√£o segue: `logico` -> `inteiro` -> `numerico` -> `complexo` ->
`caracter`, onde -> pode ser lido como *foram transformados em*. Voc√™ pode for√ßar a coer√ß√£o contra essa ordem usando fun√ß√µes `as.`:

```{r}
character_vector_example <- c('0','2','4')
character_vector_example
character_coerced_to_numeric <- as.numeric(character_vector_example)
character_coerced_to_numeric
numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)
numeric_coerced_to_logical
```

Como voc√™ pode ver, algumas coisas surpreendentes podem acontecer quando o R for√ßa algum tipo b√°sico de dados em outro! Pormenores da coer√ß√£o de tipo a parte:  se seus dados n√£o se parecem com o que voc√™ pensava que eles deveria se parecer, a coer√ß√£o de tipo pode ser a culpada; tenha certeza qe tudo no seus vetores √© do mesmo tipo e nas suas colunas de data.frames, ou voc√™ ter√° supresas desagrad√°veis!

Mas a coer√ß√£o tamb√©m pode ser bastante √∫til! Por exemplo, nos nossos dados `cats`
`likes_string` √© num√©rico, mas n√≥s sabemos que os 1s and 0s representam na realidade `VERDADEIRO` e `FALSO` (uma maneira comum de represent√°-los). N√≥s devemos usar o tipo de dados `l√≥gico` aqui, que tem dois estados: `VERDADEIRO` ou `FALSO`, que √© exatamente o que nossos dados representam. N√≥s podemos 'coagir' esssa coluna para que seja`l√≥gica` ussando a fun√ß√£o `as.logical`:

```{r}
cats$likes_string
cats$likes_string <- as.logical(cats$likes_string)
cats$likes_string
```

A fun√ß√£o `c()` tamb√©m ir√° anexar coisas a um vetor existente:

```{r}
ab_vector <- c('a', 'b')
ab_vector
combine_example <- c(ab_vector, 'SWC')
combine_example
```

Voc√™ tamb√©m pode fazer s√©ries de n√∫meros:

```{r}
mySeries <- 1:10
mySeries
seq(10)
seq(1,10, by=0.1)
```

Podemos fazer algumas perguntas a respeito de vetores:

```{r}
sequence_example <- seq(10)
head(sequence_example, n=2)
tail(sequence_example, n=4)
length(sequence_example)
class(sequence_example)
typeof(sequence_example)
```

Por fim, voc√™ pode nomear os elementos em seu vetor:

```{r}
my_example <- 5:8
names(my_example) <- c("a", "b", "c", "d")
my_example
names(my_example)
```

> ## Desafio 1
>
> Comece criando um vetor com os n√∫meros 1 a 26.
> Multiplique o vetor por 2, e d√™ ao vetor resultante nomes de A a Z (dica: 
> existe um atributo em vetores chamado `LETTERS`)

> > ## Solu√ß√£o do Desafio 1
> >
> > ```{r}
> > x <- 1:26
> > x <- x * 2
> > names(x) <- LETTERS
> > ```
> {: .solution}
{: .challenge}


## Data Frames

Dizems que colunas nos data.frames s√£o vetores:

```{r}
str(cats$weight)
str(cats$likes_string)
```

Isso faz sentido. Mas e quanto a

```{r}
str(cats$coat)
```

## Factors

Outro tipo importante de estrutura de dados √© chamado de *factor*. Fatores usualmente se parecem com dados de caracter, mas s√£o tipicamente utilizados para representar informa√ß√£o categ√≥rica. Por exemplo, vamos criar um vetor rotulando colora√ß√µes de gato para todos os gatos em nosso estudo:


```{r}
coats <- c('tabby', 'tortoiseshell', 'tortoiseshell', 'black', 'tabby')
coats
str(coats)
```


Podemos transformar um vetor em um fator assim:

```{r}
CATegories <- factor(coats)
class(CATegories)
str(CATegories)
```


Agora o R notou que existem tr√™s categorias poss√?veis em nossos dados - mas isso
tamb√©m fez algo surpreendente; Em vez de imprimir as sequ√™ncias que n√≥s demos,
temos um monte de n√∫meros.O R substituiu nossas categorias por √?ndices numerdos:

```{r}
typeof(coats)
typeof(CATegories)
```

> ## Desafio 2
>

> Existe um fator no nosso data.frame`cats`? Qual o nome dele?
> Tente usar `? Read.csv` para descobrir como manter as colunas de texto como
> vetores  de caracteres em vez de fatores; Ent√£o escreva um comando ou dois para
> mostrar que o fator em `cats` √© realmente um vetor de caracteres quando
> carregado dessa maneira.

> > ## Solu√ß√£o do Desafio 2
> >
> > Uma solu√ß√£o √© usar o argumento `stringAsFactors`:
> >
> > ```{r, eval = FALSE}
> > cats <- read.csv(file="data/feline-data.csv", stringsAsFactors=FALSE)
> > str(cats$coat)
> > ```
> >
> > Outra solu√ß√£o √© usar o argumento `colClasses`
> > que permite um controle mais fino.
> >
> > ```{r, eval = FALSE}
> > cats <- read.csv(file="data/feline-data.csv", colClasses=c(NA, NA, "character"))
> > str(cats$coat)
> > ```
> >
> > Nota: os alunos menos experientes acham os arquivos de ajuda dif√?ceis de entender; Certifique-se de deix√°-los saber que isso √© comum, e incentiv√°-los a darem seu melhor palpite com base no significado sem√¢ntico, mesmo que eles n√£o tenham certeza..
> {: .solution}
{: .challenge}


Nas fun√ß√µes de modelagem, √© importante saber quais s√£o os n√?veis de linha de
base. Este √© considerado o primeiro fator, mas por padr√£o os fatores s√£o
rotulados em ordem alfab√©tica. Voc√™ pode alterar isso especificando os n√?veis:


```{r}
mydata <- c("case", "control", "control", "case")
factor_ordering_example <- factor(mydata, levels = c("control", "case"))
str(factor_ordering_example)
```


Neste caso, explicitamente dissemos ao R que "controle" deve ser representado por
1, e "Case" por 2. Esta designa√ß√£o pode ser muito importante para a interpreta√ß√£o
dos resultados de modelos estat√?sticos!

## Listas


Outra estrutura de dados que voc√™ vai querer em seu saco de truques √© a `lista`.
Uma lista √© mais simples em alguns aspectos do que os outros tipos, porque voc√™
pode colocar qualquer coisa que voc√™ quiser nele:

```{r}
list_example <- list(1, "a", TRUE, 1+4i)
list_example
another_list <- list(title = "Research Bazaar", numbers = 1:10, data = TRUE )
another_list
```


Agora podemos entender algo um pouco surpreendente em nosso data.frame; O que
acontece se rodarmos:

```{r}
typeof(cats)
```

Vemos que os data.frames parecem listas - isto √© porque um data.frame √© realmente
uma lista de vetores e fatores, como eles t√™m que ser - para manter essas colunas
que s√£o uma mistura de vetores e fatores, o data.frame precisa de algo um pouco
mais flex√?vel do que um vetor para colocar todas as colunas em uma tabela
familiar. Em outras palavras, um `data.frame` √© uma lista especial em que todos
os vetores devem ter o mesmo comprimento.

Em nosso exemplo de `gatos`, temos um n√∫mero inteiro, um duplo e uma vari√°vel
l√≥gica. Como j√° vimos, cada coluna do data.frame √© um vetor.

```{r}
cats$coat
cats[,1]
typeof(cats[,1])
str(cats[,1])
```


Cada linha √© uma * observa√ß√£o * de diferentes vari√°veis, ela pr√≥pria √© um
data.frame, e assim, pode ser composto de elementos de diferentes tipos

```{r}
cats[1,]
typeof(cats[1,])
str(cats[1,])
```

> ## Desafio 3
>
> H√° v√°rias maneiras sutilmente diferentes de chamar vari√°veis, observa√ß√µes e
> elementos dos data.frames:
>
> - `cats[1]`
> - `cats[[1]]`
> - `cats$coat`
> - `cats["coat"]`
> - `cats[1, 1]`
> - `cats[, 1]`
> - `cats[1, ]`
>

> Experimente estes exemplos e explique o que √© devolvido por cada um.
>
> * Dica: * Use a fun√ß√£o `typeof ()` para examinar o que √© retornado em cada
> caso.
>
> > ## Solu√ß√£o do Desafio 3
> > ```{r, eval=TRUE, echo=TRUE}
> > cats[1]
> > ```

> > Podemos pensar em um data frame como uma lista de vetores. O colchetes `[1]`
> > retorna a primeira fatia da lista, como outra lista. Neste caso, √© a primeira
> > coluna do data frame.
> > ```{r, eval=TRUE, echo=TRUE}
> > cats[[1]]
> > ```
> > O colchete duplo `[[1]]` retorna o conte√∫do do item da lista. Nesse caso
> > √© o conte√∫do da primeira coluna, um _vetor_ do tipo _fator_.
> > ```{r, eval=TRUE, echo=TRUE}
> > cats$coat
> > ```
> > Este exemplo usa o caractere `$` para endere√ßar itens por nome. _coat_ √© a
> > primeira coluna do data frame, novamente um _vetor_ do tipo _fator_.
> > ```{r, eval=TRUE, echo=TRUE}
> > cats["coat"]
> > ```
> > Aqui estamos usando o colchete simples `["coat"]` substituindo o √?ndice
> > num√©rico pelo nome da coluna. Como no exemplo 1, o objeto de retorno √© uma
> > _lista_.
> > ```{r, eval=TRUE, echo=TRUE}
> > cats[1, 1]
> > ```
> > Este exemplo usa um colchete √∫nico, mas desta vez n√≥s fornecemos as
> > coordenadas de linha e coluna. O objeto retornado √© o valor na linha 1,
> > coluna 1. O objeto √© um _inteiro_ mas porque √© parte de um _vetor_ do tipo
> > _fator_, o R exibe o r√≥tulo "calico" associado com o valor inteiro
> > ```{r, eval=TRUE, echo=TRUE}
> > cats[, 1]
> > ```
> > Como no exemplo anterior, usamos colchetes simples e fornecemos coordenadas
> > de  linhas e colunas. A coordenada da linha n√£o √© especificada, o R
> > interpreta o valor faltante como todos os elementos deste _vetor_ _coluna_.
> > ```{r, eval=TRUE, echo=TRUE}
> > cats[1, ]
> > ```
> > Novamente, usamos o colchete √∫nico com coordenadas de linha e coluna. A
> > coordenada da coluna n√£o √© especificada. O valor de retorno √© uma _lista_
> > contendo todos os valores na primeira linha.
> {: .solution}
{: .challenge}

## Matrizes

Por √∫ltimo mas n√£o menos importante √© a matriz. Podemos declarar uma matriz cheia
de zeros:

```{r}
matrix_example <- matrix(0, ncol=6, nrow=3)
matrix_example
```

E semelhante a outras estruturas de dados, podemos perguntar coisas sobre a nossa
matriz:

```{r}
class(matrix_example)
typeof(matrix_example)
str(matrix_example)
dim(matrix_example)
nrow(matrix_example)
ncol(matrix_example)
```

> ## Desafio 4
>
> Qual voc√™ acha que ser√° o resultado de
> Tente.
> Voc√™ acertou? Porque / Porque n√£o?
>
> > ## Solu√ß√£o do Desafio 4
> >
> > Qual voc√™ acha que ser√° o resultado de
> > `length(matrix_example)`?
> >
> > ```{r}
> > matrix_example <- matrix(0, ncol=6, nrow=3)
> > length(matrix_example)
> > ```
> >
> > Porque uma matriz √© um vetor com atributos de dimens√£o adicionados, `length`
> > fornece o n√∫mero total de elementos na matriz.
> {: .solution}
{: .challenge}


> ## Desafio 5
>
> Crie outra matriz, dessa vez contendo os n√∫meros de 1 a 50,
> com 5 colunas e 10 linhas.
> Sua fun√ß√£o`matrix` preencheu sua matriz por colunas ou por linhas, esse √© o
> comportamento padr√£o?
> Veja se voc√™ descobre como mudar isto.
> (Dica: leia a documenta√ß√£o para `matrix`!)
>
> > ## Solu√ß√£o para o Desafio 5

> > ```{r, eval=FALSE}
> > x <- matrix(1:50, ncol=5, nrow=10)
> > x <- matrix(1:50, ncol=5, nrow=10, byrow = TRUE) # to fill by row
> > ```
> {: .solution}
{: .challenge}


> ## Desafio 6

> Crie uma lista de comprimento dois contendo um vetor de caracteres para cada
uma das se√ß√µes nesta parte da oficina:
>
>  - Tipos de dados
>  - Estruturas de dados
>
> Preencha cada vetor de caracteres com os nomes dos tipos de dados e estruturas
> de dados que vimos at√© agora
>
> > ## Solu√ß√£o do Desafio 6
> > ```{r}
> > dataTypes <- c('double', 'complex', 'integer', 'character', 'logical')
> > dataStructures <- c('data.frame', 'vector', 'factor', 'list', 'matrix')
> > answer <- list(dataTypes, dataStructures)
> > ```
> > Nota: √© bom fazer uma lista em letras grandes numa placa ou gravado na parede
> > lista ndo todos esses tipos e estruturas - Deixe-o para o resto da oficina
> > para lembrar as pessoas da import√¢ncia dessas no√ß√µes b√°sicas.

> {: .solution}
{: .challenge}


> ## Desafio 7
>
> Considere a sa√?da do R da matriz abaixo:
> ```{r, echo=FALSE}
> matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> ```
> Qual foi o comando correto usado para escrever essa matriz? Examine cada
> comando e tente descobrir o correto antes de digit√°-los. Pense em quais
> matrizes os outros comandos produzir√£o.
>
> 1. `matrix(c(4, 1, 9, 5, 10, 7), nrow = 3)`
> 2. `matrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)`
> 3. `matrix(c(4, 9, 10, 1, 5, 7), nrow = 2)`
> 4. `matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)`
>
> > ## Solu√ß√£o do Desafio 7
> >

> > ```{r, eval=FALSE}
> > matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> > ```
> {: .solution}
{: .challenge}
